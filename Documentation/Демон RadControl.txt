Алгоритм работы демона RadControl:
1. Установить обработчик системных сигналов
2. Загрузить настройки из файла RadControl.cfg
3. Установить соединение c mysql базой данных
4. Установить настройки связи по протоколу modbus библиотеки libmodbus
5. Создать, открыть и установить размер файла разделяемой памяти
6. Открыть очередь сообщений для команд демону
7. Создать и инициализировать объекты класса "Detector"
8. Установить бит в файле разделяемой памяти, показывающий, что демон запущен
9. Занести запись в архивную базу данных о том, что демон запущен
10. Основной цикл: вызывать для объектов Detector метод update с некоторым пероидом (своим для каждого детектора), принимать и обрабатывать сообщения по очереди сообщений
11. Если основной цикл был прерван, занести в архивную базу данных сообщение об остановке демона, освободить память, снять бит "демон работает" в файле разделяемой памяти

Подробно по этим шагам:
1. Демон должен оставлять сообщение об остановке даже если его "убили" через консоль или он "упал" из-за SEGFAULT-a. Для этого используется системный вызов signal, который сообщает операционной системы, что программа готова обработать системыные сигналы SIGINT (процесс прерван), SIGTERM (процесс принудительно завершён) и SIGSEGV (ошибка сегментирования, процесс обратился по недействительному адресу памяти). Вызов signal устанавливает обработчик системных сигналов. Обработчиком является функция signal_handler.

2. За загрузку настроек отвечает функция load_options. Она открывает файл RadControl.cfg и загружает оттуда адреса modbus, которые демон должен опрашивать, и путь к файлу устройства (device node), который определяет, по какому порту компьютера будет идти связь.
Файл RadControl.cfg имеет формат:
"
MODBUS_IDS=<modbus-адреса как десятичные числа, через пробел>
DEVICE_NODE=<полный путь к файлу устройства>
"
Функция load_options будет искать файл в рабочей директории процесса.

3. Для связи с mysql-базой данных используется библиотека Qt и её классы QSqlDatabase и QSqlQuery.
При инициализации открывается соединение с базой данных, демон использует логин и пароль "rad_control_bot","hflrjynhjkm", они указаны в коде. 
Для занесения сообщений о событиях в таблицу "log" архивной базы данных используются функции log и detector_log.
Функция "void log(string msg)" заносит строку msg в поле "message" таблицы "log" базы данных.
Функция "void Detector::detector_log(string msg)" делает то же самое, но дописывает в начало сообщения, к какому детектору оно относится, то есть приписывает слева "Detector N:", где N - modbus-номер.
Эти две функции реализованы в файле Detector.cc
Если демон был скомпилирован с флагом NODATABASE, фукнции log и detector_log выводят сообщения не в базу данных, а в консоль.
Справку по библиотеке Qt можно открыть командой:
assistant
Там можно найти описание использованных классов QSqlQuery и QSqlDatabase.

4. Информацию по использованной библиотеке libmodbus можно получить командой:
man libmodbus

5. Для создания и одновременного открытия файла разделяемой памяти используется команда open с параметрами O_RDWR|O_CREAT. Для изменения размера файла сначала системным вызовом lseek происходит перемещение указателя в файле на место, где должен располагаться последний байт файла, затем вызовом write туда записывается бинарный 0 (он же '\0'). При изначально длина файла была нулевой, при записи за конец файла система увеличивает его до необходимого размера.

6. Перед тем как создать очередь сообщений, демон проверяет, не существует ли она уже, и удаляет старую, если она существует. Очередь сообщений команд создаётся и открывается системным вызовом mq_open. При этом указывается максимальное число сообщений в очереди - 10 - и максимальный размер сообщения --- 6 байт.
Структура сообщения описана в файле DetectorData.h: 1-й байт - код команды, следующие - аргументы команды. Коды команд перечислены в "enum class Command":
*SHUTDOWN - команда на выключение демона, нет аргументов
*SET_EXPOSURE - установить экспозицию. Аргументы: 1 байт (unsigned char) --- modbus-номер детектора, 2 байта (uint16_t) новая экспозиция.
*SET_EXPOSURE_BY_COUNT - установить экспозицию по счёту. Аргументы: 1 байт (unsigned char) --- modbus-номер детектора, 2 байта (uint16_t) новая экспозиция по счёту.
*SET_SENSITIVITY - установить чувствительность. Аргументы: 1 байт (unsigned char) --- modbus-номер детектора, 4 байта (float) новая чувствительность.

В текущей версии ПО tango-сервер отправляет команды SET_EXPOSURE. Остальные команды никто не отправляет.

В текущей версии программы есть баг, который я не успел поправить. Он заключается в том, что если сначала запустить RadControl, затем запустить tango-сервер, затем перезапустить RadControl, то tango-сервер не сможет передавать команды демону, так как при перезапуске RadControl начинает принимать сообщения по новой очереди сообщений, а не по той, которую открыл tango-сервер.

7. За общение с каждым отдельным детектором отвечает класс "Detector". Функция main отвечает за создание объектов этого класса и вызов метода update в нужное время. Ниже этот класс описан подробно.

8. Первый байт в файле разделяемой памяти хранит биты состояния. На данном этапе, после инициализации, демон выставляет там биты:
0b00000001 означает, что демон запущен
0b00000010 выставляется, если не удалось установить соединение с mysql базой данных

9. Вызывается функция log с параметром "Started", если демон запущен в нормальном режиме, либо "Started in DUMMY mode", если в отладочном. Функция log заносит соответствующее сообщение в архивную базу данных.

10. Основной цикл функции main отвечает за вызов метода update для каждого объекта класса Detector в нужное время. Это время определяется переменной (полем класса) Detector::time_to_update. Методы класса Detector записывают в эту переменную время в миллисекундах, которое должно пройти от текущего момента до следующего момента, когда main должен вызвать update.
Например, пока нет соединения с детектором, метод update при каждом вызове пытается восстановить соединение и выставляет time_to_update=10000. Это означает, что пока детектор отключён, попытка найти его будет предприниматься один раз в 10 секунд.
Если связь стабильная и проблем нет, метод update выставляет time_to_update на время, равное текущей экспозиции детектора.
Для того, чтобы обновлять каждый объект класса Detector в заказанное им время, в основном цикле функции main используется следующий алгоритм: (псевдокод)
*0.last_update=текущее_время()           #момент времени предыдущего обновления
*1.now=текущее_время()
*2.dt=now-last_update                    #dt=время, прошедшее с последнего обновления
*3.for i from 0 to NDETECTORS:           #для каждого детектора
*3.1.  detector[i].time_to_update-=dt    #уменьшить его оставшееся время ожидания на прошедшее время
*3.2.  if detector[i].time_to_update<=0: #если после этого время ожидания меньше либо равно нулю, то детектор пора обновить
*3.3.    detector[i].update()            #обновить детектор, при этом он выставляет новое положительное значение time_to_update
*4.Среди всех детекторов найти наименьшее значение time_to_update, обозначим его min
*5.timeout=min+last_update               #следующий момент времени, когда нужно обновить какой-то из детекторов
*6.ждать_до_момента_времени(timeout)#или до прихода команды по очереди сообщений
*7.last_update=now
*8.GO TO *1
Для ожидания в пункте *6 используется системный вызов mq_timedreceive. Он может быть прерван преждевременно пришедшим в очередь сообщений сообщением. В этом случае демон прервётся на обработку сообщения. В результате обработки сообщения какой-то из детекторов может изменить своё значение time_to_update. Поэтому, получив любое сообщение, ожидание заканчивается а алгоритм переходит к следующему пункту *7.

11. В случае, если демон был прерван сигналами SIGINT,SIGSEGV или SIGTERM, функция signal_handler заносит запись об этом в базу данных и вызывает функцию cleanup. Функция cleanup уничтожает объекты детекторов, закрывает очередь сообщений команд, устанавливает все биты байта состояния в фале разделяемой памяти на 0, показывая, что демон выключился, закрывает разделяемую память, закрывает соединение с mysql-базой данных, закрывает соединение по модбасу и освобождает память библиотеки libmodbus.

Описание класса Detector
Каждый объект класса Detector отвечает за общение с одним детектором, за поддержание актуальности соответствующей записи в файле разделяемой памяти и за занесение показаний и сообщений в архивную базу данных, имеющих одношение к данному детектору.
Класс определён и реализован в файлах Detector.h и Detector.cc соответственно.
Поля класса:
*DetectorData*d; - указатель на ту структуру типа DetectorData в разделяемой памяти, которая соответствует детектору, за общение с которым отвечает данный объект класса Detector.
*bool configured; - этот флаг означает, что нужные значения экспозиции, экспозиции по счёту и чувствительности были выставлены и больше их выставлять не нужно
*bool data_ready; - этот флаг означает, что детектор уже закончил хотя бы одно измерение. Если этот флаг не стоит, то нужно не читать показания детектора, а ждать, пока он закончит первое измерение
*bool problem_calibration; - этот флаг означает, что калибровочный файл не был найден. Изначально он имеет значение false. Когда он меняет состояние с false на true, в базу данных заносится сообщение о том, что не найден калибровочный файл. Если же его значение меняется с true на false, заносится сообщение о том, что при повторной попытке файл с калибровочными данными всё же был найден.
*bool problem_connection; - этот флаг означает, что соединение с детектором было потеряно. Изначально он имеет значение false. Когда он меняет состояние с false на true, в архивную базу данных заносится сообщение о том, соединение с детектором было потеряно. Если же его значение меняется с true на false, заносится сообщение о том, что соединение с детектором восстановлено. 
*interpolant::Interpolant*calibration; указатель но объект класса Interpolant, используемый для преобразования счёта в секунду в микроЗиверты в час. Объект класса Interpolant хранит загруженные точки и интерполирует. Для нейтронных детекторов и для гамма, в случае если не найден файл с калибровочными данными, этот указатель имеет значение nullptr (оно же 0, оно же NULL).
*int time_to_update; - время в миллисекундах, оставшееся до следующего момента, когда нужно опросить детектор. Сам объект класса Detector выставляет значение этой переменной на желаемое значение, а функция main использует сравнивает значение у разных детекторов, чтобы понять, сколько нужно подождать, уменьшает значение этой переменной, если какое-то время прошло, и вызывает метод update(), когда время истекло.
Методы класса:
*~Detector(); - деструктор. Устанавливает указанное у разделяемой памяти состояние детектора (d->state) на DISABLED, и освобождает память, если ранее она была выделена под калибровочные точки.
*void init(DetectorData*); - инициализация объекта. Выставляет начальные значения переменным в разделяемой памяти и полям объекта. Данный метод вызывается из функции main при инициализации.
*void update(); - опрос детекторов. Подробно описан ниже.
*void set_exposure(uint16_t val); - установить экспозицию.
*void set_exposure_by_count(uint16_t val); - установить экспозицию по счёту
*void set_sensitivity(float val); - установить чувствительность
*void detector_log(std::string msg); - записать сообщение в базу данных, прдварительно приписав к нему слева "Detector N:", где N - modbus-адрес детектора
*void switch_slave(); - указать бибиотеке libmodbus, по какому modbus-адресу следует осуществлять дальнейшую связь, и подождать небольшое время.
TODO почему нужно ждать после переключения modbus-адреса?
*void handle_connection_loss(); - обработать потерю связи, а именно:
p1. Установить значение флага problem_connection=true, занести запись в базу данных, если при этом значение флага изменилось
p2. Установить configured=false, так как после восстановления соединения нужно вновь убедиться, что параметры работы детектора выставлены правильно
p3. Установить data_ready=false, так как после восстановления соединения нужно вновь убедиться, что детектор закончил первое измерение
p4. Установить состояние детектора в разделяемой памяти d->state=DetectorState::NO_CONNECTION
p5. Установить time_to_update=10000, чтобы функция main вызвала метод update для данного детектора через 10 секунд. То есть назначить попытку восстановления соединения на 10 секунд после текущего момента.

*void update(); - убедиться, что детектор настроен и обновить показания
Метод проходит через следующие этапы:
0.Переключить функции библиотеки limodbus на нужный детектор вызовом метода switch_slave
1.Убедиться, что определён тип детектора - гамма или нейтронный
2.Убедиться, что детектору были выставлены настройки --- экспозиция и экспозиция по счёту, --- и загружены калибровочные точки
3.Убедиться, что детектор закончил первое измерение, и что уже можно забирать показания из его регистров
4.Получить от детектора счёт и МЭД, для гамма перевести счёт и экспозицию в МЭД.
5.Записать полученные данные в архивную базу данных
На каждом из этих этапов может возникнуть исключение, тогда эта последовательность преждевременно прерывается.
Подробнее по этим шагам:
1.Тип детектора хранится в переменной d->type в разделяемой памяти. Если её значение соответствует гамма или нейтронному детектору, этот шаг пропускается. Если d->type==DetectorType::UNKNOWN_TYPE, то нужно определить тип детектора. Для этого производится чтение из регистра 3(адрес блока). Для нейтронных детекторов там стоит 20, для гамма 100.
2.Флаг configured показывает, был ли детектор уже ранее настроен. Если configured==true, можно перейти к следующему шагу. Если configured==false, то нужно настроить детектор и отметить configured=true.
Для гамма-детектора для этого нужно выставить нужную экспозицию в регистр 125 и загрузить калибровочные точки из файла.
Для найстройки нейтронного детектора нужно выставить значения экспозиции (регистр 49) и экспозиции по счёту (регистр 21)
3.Флаг data_ready показывает, было ли первое измерение закончено ещё ранее. Если data_ready==true, на этом шаге ничего делать не надо. Если data_ready==false, то нужно убедиться, что показания в регистрах детектора действительны и установить data_ready=true.
Для гамма-детектора для этого нужно убедиться, что выставлен 6-ой бит статусного регистра 37 (бит (register37>>6)&1). Если он не выставлен, показания не готовы и метод update нужно прервать на этом этапе.
4.Для гамма детектора считывается показание счёта из регистров 104:105, МЭД определяется по калибровочному графику, где на оси X отложен счёт/экспозиция.
5.Полученные показания заносятся в базу данных.

Сборка
Демон был написан с использованием библиотеки Qt для взаимодействия с mysql - базой данных и использует систему сборки Qt --- qmake.

В файле проекта RadControl.pro укзаны файлы исходного кода, заголовочные файлы, флаги компиляции.

Были ипользованы три дополнительных флага, влияющие на компиляцию:
DEBUG - включает отладочную печать
DUMMY - вместо общения с детекторами демон будет брать показания "с потолка"
NODATABASE - запись в mysql базу данных не будет производиться.
